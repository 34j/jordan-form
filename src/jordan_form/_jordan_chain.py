import warnings
from collections.abc import Sequence
from typing import Any, Literal, Protocol, overload

import attrs
import numpy as np
import scipy
import scipy.special
from numpy.typing import NDArray

from jordan_form._multiplicity import (
    AlgebraicMultiplicity,
    _matrix_rank_from_s,
    get_tol,
)


@attrs.frozen(kw_only=True)
class JordanChains(AlgebraicMultiplicity):
    chains: list[np.ndarray[tuple[int, int], np.dtype[np.number]]]
    """The Jordan chains of shape (l_chain, n)."""

    @property
    def chain_lengths(self) -> np.ndarray[tuple[int], np.dtype[np.int_]]:
        """
        The length of the Jordan chains.

        Known as Segre number.

        References
        ----------
        大竹 剛, 古賀 雅伸 and 三平 満司. 2002.
        行列のジョルダン標準形の数値計算法.
        システム制御情報学会論文誌 15, 7 (2002), 320–326.
        https://doi.org/10.5687/iscie.15.320

        """
        return np.asarray([c.shape[0] for c in self.chains])

    @property
    def dim_ith_generalized_eigenvectors(
        self,
    ) -> np.ndarray[tuple[int], np.dtype[np.int_]]:
        """
        The dimension of the space generated by the i-th generalized eigenvectors
        for oridinary eigenvalue problem.

        The dimension of the quotient space
        (i-th generalized eigenspace) / (i-1-th generalized eigenspace).

        Known as Weyr number.

        References
        ----------
        大竹 剛, 古賀 雅伸 and 三平 満司. 2002.
        行列のジョルダン標準形の数値計算法.
        システム制御情報学会論文誌 15, 7 (2002), 320–326.
        https://doi.org/10.5687/iscie.15.320

        """
        chain_lengths = self.chain_lengths
        return np.count_nonzero(
            chain_lengths[:, None] >= np.arange(chain_lengths.max())[:, None], axis=0
        )

    @property
    def dim_generalized_eigenspace(self) -> np.ndarray[tuple[int], np.dtype[np.int_]]:
        """
        The dimension of the generalized eigenspaces for oridinary eigenvalue problem.

        Known as Kågström number.

        In general, the element of Jordan chains is not orthogonal
        and this property should not be used.

        References
        ----------
        Bo Kågström and Axel Ruhe. 1980.
        An Algorithm for Numerical Computation
        of the Jordan Normal Form of a Complex Matrix.
        ACM Trans. Math. Softw. 6, 3 (Sept. 1980), 398–419.
        https://doi.org/10.1145/355900.355912

        大竹 剛, 古賀 雅伸 and 三平 満司. 2002.
        行列のジョルダン標準形の数値計算法.
        システム制御情報学会論文誌 15, 7 (2002), 320–326.
        https://doi.org/10.5687/iscie.15.320

        """
        return np.cumsum(self.dim_ith_generalized_eigenvectors)

    @property
    def num_chains(self) -> int:
        """The number of Jordan chains."""
        return len(self.chains)

    @property
    def num_generalized_eigenvectors(self) -> int:
        """The number of generalized eigenvectors."""
        return np.sum(self.dim_ith_generalized_eigenvectors)

    @property
    def eigvec_orthogonal(self) -> np.ndarray[tuple[int, int], np.dtype[np.number]]:
        """The orthogonal eigenvectors of shape (n, geometric_multiplicity)."""
        return np.stack([c[0, :] for c in self.chains], axis=1)

    @property
    def geometric_multiplicity(self) -> int:
        """
        The geometric multiplicity of the eigenvalue.

        The dimension of the eigenspace of the eigenvalue.
        Less than or equal to the algebraic multiplicity.

        """
        return self.eigvec_orthogonal.shape[1]


def fixed_jordan_chains(
    A: np.ndarray[tuple[int, int, int], np.dtype[np.number]],
    /,
    atol: float | None = None,
    rtol: float | None = None,
) -> np.ndarray[tuple[int, int, int], np.dtype[np.number]]:
    """
    Get the Jordans chain of the matrix of fixed length.

    Parameters
    ----------
    A : np.ndarray[tuple[int, int, int], np.dtype[np.number]]
        The matrix derivatives evaluated at the eigenvalue
        of shape (l_chain, n, n).
    atol : float | None, optional
        Threshold below which SVD values are considered zero.
        Defaults to ``np.finfo(A.dtype).eps``.
    rtol : float | None, optional
        Threshold below which SVD values are considered zero.
        Defaults to ``np.finfo(A.dtype).eps``.

    Returns
    -------
    np.ndarray[tuple[int, int, int], np.dtype[np.number]]
        The Jordan chains of shape (n_chain, l_chain, n).

    """
    m = A.shape[0]
    n = A.shape[1]
    mat = np.stack(
        [
            np.moveaxis(
                np.concat(
                    (
                        np.flip(
                            A[: j + 1, :, :]
                            / scipy.special.factorial(np.arange(j + 1)[:, None, None]),
                            axis=0,
                        ),
                        np.zeros((m - j - 1, n, n), dtype=A.dtype, device=A.device),
                    ),
                    axis=0,
                ),
                0,
                1,
            ).reshape(n, m * n)
            for j in range(m)
        ],
        axis=0,
    ).reshape(m * n, m * n)
    # (m*n, n_jordan_chain)
    chain = scipy.linalg.null_space(mat, rtol)
    # (n_jordan_chain, m*n)
    chain = np.moveaxis(chain, -1, 0)
    # (n_jordan_chain, m, n)
    chain = chain.reshape(chain.shape[0], m, n)
    return chain


def _get_space(
    chains: list[NDArray[np.number]],
    length: int,
    /,
) -> NDArray[np.number]:
    """
    Get the cut chains.

    Parameters
    ----------
    chains : list[NDArray[np.number]]
        The Jordan chains.
    length : int
        The length to cut.

    Returns
    -------
    NDArray[np.number]
        The cut chains of shape (n_chain, l_chain, n).

    """
    res = np.concat([chains_[:, :length, :] for chains_ in chains], axis=0)
    return res


@overload
def canonoical_jordan_chains(
    A: np.ndarray[tuple[int, int, int], np.dtype[np.number]],
    /,
    *,
    hermitian: bool | None = ...,
    atol_rank: float | None = ...,
    rtol_rank: float | None = ...,
    atol_norm: float | None = ...,
    rtol_norm: float | None = ...,
    flatten: Literal[False] = ...,
) -> list[np.ndarray[tuple[int, int, int], np.dtype[np.number]]]: ...
@overload
def canonoical_jordan_chains(
    A: np.ndarray[tuple[int, int, int], np.dtype[np.number]],
    /,
    *,
    hermitian: bool | None = ...,
    atol_rank: float | None = ...,
    rtol_rank: float | None = ...,
    atol_norm: float | None = ...,
    rtol_norm: float | None = ...,
    flatten: Literal[True] = ...,
) -> list[np.ndarray[tuple[int, int], np.dtype[np.number]]]: ...
def canonoical_jordan_chains(
    A: np.ndarray[tuple[int, int, int], np.dtype[np.number]],
    /,
    *,
    hermitian: bool | None = None,
    atol_rank: float | None = None,
    rtol_rank: float | None = None,
    atol_norm: float | None = None,
    rtol_norm: float | None = None,
    flatten: bool = True,
) -> (
    list[np.ndarray[tuple[int, int], np.dtype[np.number]]]
    | list[np.ndarray[tuple[int, int, int], np.dtype[np.number]]]
):
    """
    Get the Jordan chains of the matrix.

    Parameters
    ----------
    A : np.ndarray[tuple[int, int, int], np.dtype[np.number]]
        The matrix derivatives evaluated at the eigenvalue
        of shape (max_l_chain, n, n).
    hermitian : bool, optional
        If True, `A` is assumed to be Hermitian (symmetric if real-valued),
        enabling a more efficient method for finding singular values.
        Defaults to False.
    atol_rank : float, optional
        Threshold below which SVD values are considered zero.
        Defaults to ``np.finfo(A.dtype).eps``.
    rtol_rank : float, optional
        Threshold below which SVD values are considered zero.
        Defaults to ``np.finfo(A.dtype).eps``.
    atol_norm : float, optional
        Threshold below which norm values are considered zero.
        Defaults to ``np.finfo(A.dtype).eps``.
    rtol_norm : float, optional
        Threshold below which norm values are considered zero.
        Defaults to ``np.finfo(A.dtype).eps``.
    flatten : bool, optional
        If True, flatten the chains. Defaults to True.

    Returns
    -------
    list[NDArray[np.number]]
        The Jordan chains.
        If flatten is True, each chain is of shape (l_chain, n).
        If flatten is False, each chain is of shape (n_chain_l, l_chain, n).

    """
    chains: list[NDArray[np.number]] = []
    for i in range(A.shape[0], 0, -1):
        A = A[:i, :, :]
        chain = fixed_jordan_chains(A, atol=atol_rank, rtol=rtol_rank)
        # filter chains which first eigenvector's norm is too small
        norm = np.linalg.norm(chain[:, 0, :], axis=-1)
        norm_filter = norm > get_tol(np.max(norm), rtol=rtol_norm, atol=atol_norm)
        chain = chain[norm_filter, :, :]
        # chain = chain / norm[norm_filter, None, None]
        if not chain.size:
            continue
        if chains:
            cut_chain = _get_space(chains, i)
            # [n_chain_cut, l_chain, n]
            # [n_chain, n], [1, n_chain_cut, n] -> [n_chain, n_chain_cut]
            d = np.sum(chain[:, None, 0, :] * cut_chain[None, :, 0, :], axis=-1)
            # [n_chain, l_chain, n]
            chain = chain - np.sum(
                d[:, :, None, None] * cut_chain[None, :, :, :], axis=1
            )
        # svd, remove duplicated chains
        chain = np.swapaxes(chain, 0, 1)
        u, s, _ = np.linalg.svd(chain[0, :, :], hermitian=hermitian)
        rank = _matrix_rank_from_s(chain[0, :, :], s, atol=atol_rank, rtol=rtol_rank)
        chain = u.T[:rank] @ chain
        chain = np.swapaxes(chain, 0, 1)
        # normalize chains based on the first eigenvector
        norm = np.linalg.norm(chain[:, 0, :], axis=-1)
        chain = chain / norm[:, None, None]
        if chain.size:
            chains.append(chain)
    if flatten:
        chains = [c for chain_ in chains for c in chain_]
    return chains


class MatrixFuncProtocol(Protocol):
    def __call__(
        self,
        eigval: float,
        derv: int,
        /,
    ) -> np.ndarray[tuple[int, int], np.dtype[np.number]] | None:
        """
        Evaluate the matrix function at the eigenvalues.

        Parameters
        ----------
        eigval : NDArray[np.number]
            The eigenvalue.
        derv : int
            Maximum derivative.

        Returns
        -------
        NDArray[np.number]
            The (derv)-th derivative of
            matrix function of shape (n, n).

        """
        ...


def geig_func(
    A: np.ndarray[tuple[int, int], np.dtype[np.number]],
    B: np.ndarray[tuple[int, int], np.dtype[np.number]] | None = None,
    /,
) -> MatrixFuncProtocol:
    """
    Create a generalized eigenvalue function.

    Parameters
    ----------
    A : NDArray[np.number]
        The matrix A of shape (n, n).
    B : NDArray[np.number], optional
        The matrix B of shape (n, n), by default None.
        If None, the identity matrix is used.
        (oridanary eigenvalue problem)

    Returns
    -------
    MatrixFuncProtocol
        The matrix function λ→(A-Bλ) where (A-Bλ) is of shape (n, n).

    """
    B_ = B if B is not None else np.eye(A.shape[0])

    def inner(
        eigval: float, derv: int
    ) -> np.ndarray[tuple[int, int], np.dtype[np.number]] | None:
        derv = int(derv)
        if derv == 0:
            return A - eigval * B_
        elif derv == 1:
            return -B_
        elif derv > 1:
            return np.zeros_like(A)
        raise ValueError(f"Invalid derivative {derv=}. ")

    return inner


def all_canonical_jordan_chains(
    A: MatrixFuncProtocol,
    multiplicities: Sequence[AlgebraicMultiplicity],
    /,
    **kwargs: Any,
) -> list[JordanChains]:
    """
    Get the canonical Jordan chains of the matrix function.

    Parameters
    ----------
    A : MatrixFuncProtocol
        The matrix function.
    multiplicities : list[Multiplicity]
        The multiplicities of the eigenvalues.
    **kwargs : Any
        Additional arguments to pass to `canonoical_jordan_chains`.

    Returns
    -------
    list[JordanChains]
        The canonical Jordan chains of the matrix function.

    """
    results = []
    for multiplicity in multiplicities:
        derivatives = []
        chains = []
        for i in range(multiplicity.algebraic_multiplicity):
            derivative = A(multiplicity.eigval, i)
            if derivative is None:
                break
            derivatives.append(derivative)
            chains = canonoical_jordan_chains(np.stack(derivatives, axis=0), **kwargs)
            n_generalized_eigenvectors = np.sum([c.shape[0] for c in chains])
            if n_generalized_eigenvectors >= multiplicity.algebraic_multiplicity:
                if n_generalized_eigenvectors > multiplicity.algebraic_multiplicity:
                    warnings.warn(
                        "The number of generalized eigenvectors found "
                        "is greater than the algebraic multiplicity. "
                        "Consider using a larger value for `atol` or `rtol`.",
                        RuntimeWarning,
                        stacklevel=2,
                    )
                break
        results.append(
            JordanChains(
                eigvals=multiplicity.eigvals,
                chains=chains,
            )
        )
    return results
