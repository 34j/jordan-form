from typing import Literal, overload

import attrs
import numpy as np
import scipy
import scipy.special
from numpy.typing import NDArray

from jordan_form._multiplicity import (
    Multiplicity,
    _matrix_rank_from_s,
    get_tol,
)


@attrs.frozen(kw_only=True)
class JordanChains(Multiplicity):
    chains: list[np.ndarray[tuple[int, int], np.dtype[np.number]]]
    """The Jordan chains of shape (l_chain, n)."""

    @property
    def chain_lengths(self) -> np.ndarray[tuple[int], np.dtype[np.int_]]:
        """
        The length of the Jordan chains.

        Known as Segre number.

        References
        ----------
        大竹 剛, 古賀 雅伸 and 三平 満司. 2002.
        行列のジョルダン標準形の数値計算法.
        システム制御情報学会論文誌 15, 7 (2002), 320–326.
        https://doi.org/10.5687/iscie.15.320

        """
        return np.asarray(c.shape[0] for c in self.chains)

    @property
    def dim_ith_generalized_eigenvectors(
        self,
    ) -> np.ndarray[tuple[int], np.dtype[np.int_]]:
        """
        The dimension of the space generated by the i-th generalized eigenvectors
        for oridinary eigenvalue problem.

        The dimension of the quotient space
        (i-th generalized eigenspace) / (i-1-th generalized eigenspace).

        Known as Weyr number.

        References
        ----------
        大竹 剛, 古賀 雅伸 and 三平 満司. 2002.
        行列のジョルダン標準形の数値計算法.
        システム制御情報学会論文誌 15, 7 (2002), 320–326.
        https://doi.org/10.5687/iscie.15.320

        """
        chain_lengths = self.chain_lengths
        return np.count_nonzero(
            chain_lengths[:, None] >= np.arange(chain_lengths.max())[:, None], axis=0
        )

    @property
    def dim_generalized_eigenspace(self) -> np.ndarray[tuple[int], np.dtype[np.int_]]:
        """
        The dimension of the generalized eigenspaces for oridinary eigenvalue problem.

        Known as Kågström number.

        In general, the element of Jordan chains is not orthogonal
        and this property should not be used.

        References
        ----------
        Bo Kågström and Axel Ruhe. 1980.
        An Algorithm for Numerical Computation
        of the Jordan Normal Form of a Complex Matrix.
        ACM Trans. Math. Softw. 6, 3 (Sept. 1980), 398–419.
        https://doi.org/10.1145/355900.355912

        大竹 剛, 古賀 雅伸 and 三平 満司. 2002.
        行列のジョルダン標準形の数値計算法.
        システム制御情報学会論文誌 15, 7 (2002), 320–326.
        https://doi.org/10.5687/iscie.15.320

        """
        return np.cumsum(self.dim_ith_generalized_eigenvectors)


def fixed_jordan_chains(
    A: np.ndarray[tuple[int, int, int], np.dtype[np.number]], /
) -> np.ndarray[tuple[int, int, int], np.dtype[np.number]]:
    """
    Get the Jordans chain of the matrix of fixed length.

    Parameters
    ----------
    A : np.ndarray[tuple[int, int, int], np.dtype[np.number]]
        The matrix derivatives evaluated at the eigenvalue
        of shape (l_chain, n, n).

    Returns
    -------
    np.ndarray[tuple[int, int, int], np.dtype[np.number]]
        The Jordan chains of shape (n_chain, l_chain, n).

    """
    m = A.shape[0]
    n = A.shape[1]
    mat = np.stack(
        [
            np.moveaxis(
                np.concat(
                    (
                        np.flip(
                            A[: j + 1, :, :]
                            / scipy.special.factorial(np.arange(j + 1)[:, None, None]),
                            axis=0,
                        ),
                        np.zeros((m - j - 1, n, n), dtype=A.dtype, device=A.device),
                    ),
                    axis=0,
                ),
                0,
                1,
            ).reshape(n, m * n)
            for j in range(m)
        ],
        axis=0,
    ).reshape(m * n, m * n)
    # (m*n, n_jordan_chain)
    chain = scipy.linalg.null_space(mat)
    # (n_jordan_chain, m*n)
    chain = np.moveaxis(chain, -1, 0)
    # (n_jordan_chain, m, n)
    chain = chain.reshape(chain.shape[0], m, n)
    return chain


def proj(a_from: NDArray[np.number], a_to: NDArray[np.number], /) -> NDArray[np.number]:
    """
    Project a_from to a_to.

    Parameters
    ----------
    a_from : NDArray[np.number]
        The vector to be projected of shape (..., n).
    a_to : NDArray[np.number]
        The vector space to project to of shape (..., n, n_dim).

    Returns
    -------
    NDArray[np.number]
        The projected vector of shape (..., n).

    """
    a_to = a_to / np.linalg.norm(a_to, axis=-2, keepdims=True)
    return np.sum(np.dot(a_from, a_to) * a_to, axis=-1)


def _get_space(
    chains: list[NDArray[np.number]],
    length: int,
    /,
) -> NDArray[np.number]:
    """
    Get the cut chains.

    Parameters
    ----------
    chains : list[NDArray[np.number]]
        The Jordan chains.
    length : int
        The length to cut.

    Returns
    -------
    NDArray[np.number]
        The cut chains of shape (n_chain, l_chain, n).

    """
    res = np.concat([chains_[:, :length, :] for chains_ in chains], axis=0)
    return res


@overload
def canonoical_jordan_chains(
    A: np.ndarray[tuple[int, int, int], np.dtype[np.number]],
    /,
    *,
    hermitian: bool | None = ...,
    atol_rank: float | None = ...,
    rtol_rank: float | None = ...,
    atol_norm: float | None = ...,
    rtol_norm: float | None = ...,
    flatten: Literal[False] = ...,
) -> list[np.ndarray[tuple[int, int, int], np.dtype[np.number]]]: ...
@overload
def canonoical_jordan_chains(
    A: np.ndarray[tuple[int, int, int], np.dtype[np.number]],
    /,
    *,
    hermitian: bool | None = ...,
    atol_rank: float | None = ...,
    rtol_rank: float | None = ...,
    atol_norm: float | None = ...,
    rtol_norm: float | None = ...,
    flatten: Literal[True] = ...,
) -> list[np.ndarray[tuple[int, int], np.dtype[np.number]]]: ...
def canonoical_jordan_chains(
    A: np.ndarray[tuple[int, int, int], np.dtype[np.number]],
    /,
    *,
    hermitian: bool | None = None,
    atol_rank: float | None = None,
    rtol_rank: float | None = None,
    atol_norm: float | None = None,
    rtol_norm: float | None = None,
    flatten: bool = True,
) -> (
    list[np.ndarray[tuple[int, int], np.dtype[np.number]]]
    | list[np.ndarray[tuple[int, int, int], np.dtype[np.number]]]
):
    """
    Get the Jordan chains of the matrix.

    Parameters
    ----------
    A : np.ndarray[tuple[int, int, int], np.dtype[np.number]]
        The matrix derivatives evaluated at the eigenvalue
        of shape (max_l_chain, n, n).
    hermitian : bool, optional
        If True, `A` is assumed to be Hermitian (symmetric if real-valued),
        enabling a more efficient method for finding singular values.
        Defaults to False.
    atol_rank : float, optional
        Threshold below which SVD values are considered zero.
        Defaults to ``np.finfo(A.dtype).eps``.
    rtol_rank : float, optional
        Threshold below which SVD values are considered zero.
        Defaults to ``np.finfo(A.dtype).eps``.
    atol_norm : float, optional
        Threshold below which norm values are considered zero.
        Defaults to ``np.finfo(A.dtype).eps``.
    rtol_norm : float, optional
        Threshold below which norm values are considered zero.
        Defaults to ``np.finfo(A.dtype).eps``.
    flatten : bool, optional
        If True, flatten the chains. Defaults to True.

    Returns
    -------
    list[NDArray[np.number]]
        The Jordan chains.
        If flatten is True, each chain is of shape (l_chain, n).
        If flatten is False, each chain is of shape (n_chain_l, l_chain, n).

    """
    chains: list[NDArray[np.number]] = []
    for i in range(A.shape[0], 0, -1):
        A = A[:i, :, :]
        chain = fixed_jordan_chains(A)
        # filter and normalize based on the first element
        norm = np.linalg.norm(chain[:, 0, :], axis=-1)
        norm_filter = norm > get_tol(np.max(norm), rtol=rtol_norm, atol=atol_norm)
        chain = chain[norm_filter, :, :]
        chain = chain / norm[norm_filter, None, None]
        if not chain.size:
            continue
        if chains:
            cut_chain = _get_space(chains, i)
            # [n_chain_cut, l_chain, n]
            # [n_chain, n], [1, n_chain_cut, n] -> [n_chain, n_chain_cut]
            d = np.sum(chain[:, None, 0, :] * cut_chain[None, :, 0, :], axis=-1)
            # [n_chain, l_chain, n]
            chain = chain - np.sum(
                d[:, :, None, None] * cut_chain[None, :, :, :], axis=1
            )
        # svd, remove duplicated chains
        chain = np.swapaxes(chain, 0, 1)
        u, s, _ = np.linalg.svd(chain[0, :, :], hermitian=hermitian)
        rank = _matrix_rank_from_s(chain[0, :, :], s, atol=atol_rank, rtol=rtol_rank)
        chain = u.T[:rank] @ chain
        chain = np.swapaxes(chain, 0, 1)
        if chain.size:
            chains.append(chain)
    if flatten:
        chains = [c for chain_ in chains for c in chain_]
    return chains
